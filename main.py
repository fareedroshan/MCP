# Main AI Agent Orchestrator
import os
import json # For loading device configs if any, and context display
import time

# Import Agent Modules
from src.ai_agent.connectors.device_connector import DeviceConnector
from src.ai_agent.context.context_builder import ContextBuilder
from src.ai_agent.llm.llm_query_engine import LLMQueryEngine
from src.ai_agent.validation.command_validator import CommandValidator
from src.ai_agent.execution.executor import Executor
from src.ai_agent.feedback.feedback_parser import FeedbackParser
from src.ai_agent.security.security_manager import SecurityManager
from src.ai_agent.utils.logger import get_logger, log_interaction

# Initialize logger for the main application
app_logger = get_logger("AIAgentApp")

# Configuration (could be loaded from a file or environment variables)
# Example: Load OpenAI API Key
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    app_logger.warning("OPENAI_API_KEY environment variable not set. LLM queries will fail.")
    # exit("OPENAI_API_KEY not set. Exiting.") # Or handle gracefully

# Path for storing encrypted device credentials
CREDENTIAL_STORE_FILE = "device_credentials.enc"
# Encryption key for credentials. MANAGE THIS SECURELY.
# For PoC, can be from env var, or auto-generated by SecurityManager if not found.
AI_AGENT_ENCRYPTION_KEY = os.getenv("AI_AGENT_ENCRYPTION_KEY")


class AIAgent:
    def __init__(self, device_config, llm_api_key, agent_encryption_key=None, cred_store_path=CREDENTIAL_STORE_FILE):
        self.device_config = device_config # {'id': 'my-linux', 'ip': '...', 'os_type': 'linux'}
        self.device_id = device_config.get('id', device_config.get('ip', 'unknown_device'))
        self.os_type = device_config.get('os_type', 'linux') # Default to linux if not specified

        app_logger.info(f"Initializing AI Agent for device: {self.device_id} ({self.os_type})")

        self.security_manager = SecurityManager(
            credential_store_path=cred_store_path,
            encryption_key=agent_encryption_key
        )

        device_creds = self.security_manager.get_device_credentials(self.device_id)
        if not device_creds:
            app_logger.error(f"Credentials not found for {self.device_id}. Agent cannot connect.")
            # In a real app, might prompt to set them up or halt for this device.
            # For now, we allow it to proceed but connection will fail.
            self.connector = None # Mark as unable to connect
        else:
            self.connector = DeviceConnector(
                hostname=device_config['ip'],
                username=device_creds['username'],
                password=device_creds['password']
            )

        self.context_builder = ContextBuilder(self.connector)
        self.current_context = None # Will be populated after connection and context gathering

        try:
            self.llm_engine = LLMQueryEngine(api_key=llm_api_key) if llm_api_key else None
            if not self.llm_engine:
                app_logger.warning(f"LLM Engine not initialized for {self.device_id} due to missing API key.")
        except ValueError as e: # Handles API key error from LLMQueryEngine
            app_logger.error(f"Failed to initialize LLM Engine for {self.device_id}: {e}")
            self.llm_engine = None


        # Validator and Executor are initialized later if context is available
        self.validator = None
        self.executor = None
        self.feedback_parser = None


    def initialize_agent_session(self):
        """Connects to the device and gathers initial context."""
        if not self.connector:
            app_logger.error(f"[{self.device_id}] Cannot initialize session: Connector not available (check credentials).")
            return False

        app_logger.info(f"[{self.device_id}] Attempting to connect...")
        if self.connector.connect():
            app_logger.info(f"[{self.device_id}] Successfully connected. Gathering context...")
            self.current_context = self.context_builder.gather_context(os_type=self.os_type)
            if self.current_context:
                app_logger.info(f"[{self.device_id}] Context gathered: {json.dumps(self.current_context, indent=2)}")
                # Initialize components that depend on context
                self.validator = CommandValidator(self.current_context)
                self.executor = Executor(self.connector, self.validator)
                self.feedback_parser = FeedbackParser(self.current_context)
                return True
            else:
                app_logger.error(f"[{self.device_id}] Failed to gather context after connecting.")
                self.connector.disconnect()
                return False
        else:
            app_logger.error(f"[{self.device_id}] Failed to connect to device.")
            return False

    def process_user_request(self, user_query, auto_execute=False):
        """Handles a natural language request from the user."""
        if not self.current_context:
            app_logger.error(f"[{self.device_id}] Cannot process request: No device context. Initialize session first.")
            return "Error: No device context. Please connect and gather context first."
        if not self.llm_engine:
            app_logger.error(f"[{self.device_id}] Cannot process request: LLM Engine not available.")
            return "Error: LLM Engine not available."
        if not self.executor or not self.validator or not self.feedback_parser:
            app_logger.error(f"[{self.device_id}] Executor/Validator/Parser not initialized.")
            return "Error: Core execution components not ready."

        app_logger.info(f"[{self.device_id}] Received user query: '{user_query}'")

        # 1. Query LLM for commands
        app_logger.info(f"[{self.device_id}] Querying LLM...")
        llm_suggested_commands = self.llm_engine.query_llm(user_query, self.current_context)

        if not llm_suggested_commands:
            app_logger.error(f"[{self.device_id}] LLM did not return any commands.")
            log_interaction(app_logger, self.device_id, user_query, "N/A", "N/A", "LLM returned no commands.", False)
            return "Error: LLM failed to provide commands."

        app_logger.info(f"[{self.device_id}] LLM suggested commands:\n{llm_suggested_commands}")

        # (Optional) LLM Response Filtering by SecurityManager
        llm_suggested_commands = self.security_manager.filter_llm_response(llm_suggested_commands)

        # 2. Validate and Execute (Executor handles validation via CommandValidator)
        # The executor will ask for confirmation by default if not in auto_execute mode.
        # For this CLI main.py, we might want to control this more explicitly.

        # Simulate user confirmation for non-auto_execute mode
        execute_now = auto_execute
        if not auto_execute:
            try:
                confirm = input(f"Proceed to execute these commands on {self.device_id}? (yes/no) [no]: ").strip().lower()
                if confirm == 'yes':
                    execute_now = True
            except EOFError: # Handle non-interactive environments gracefully
                app_logger.warning(f"[{self.device_id}] No user input for confirmation, defaulting to no execution.")
                execute_now = False


        if execute_now:
            app_logger.info(f"[{self.device_id}] Proceeding with command execution.")
            # The executor's `execute_commands_on_device` already calls the validator.
            # It expects a string of commands, one per line.
            device_output, execution_status_msg = self.executor.execute_commands_on_device(
                llm_suggested_commands,
                self.os_type,
                ask_confirmation=False # We handled confirmation above
            )

            app_logger.info(f"[{self.device_id}] Execution status: {execution_status_msg}")
            if device_output:
                 app_logger.info(f"[{self.device_id}] Device output:\n{device_output}")

            # 3. Parse Feedback
            feedback_result = self.feedback_parser.parse_output(llm_suggested_commands, device_output, self.os_type)
            app_logger.info(f"[{self.device_id}] Feedback parsing result: {feedback_result}")

            success = feedback_result.get("success", False) # Assume failure if "success" key is missing

            # 4. Log Interaction
            log_interaction(app_logger, self.device_id, user_query, llm_suggested_commands,
                            llm_suggested_commands, # Assuming LLM commands are what's executed for now
                            device_output, success)

            # 5. (Optional) Update Context based on feedback
            if success:
                app_logger.info(f"[{self.device_id}] Task seems successful. Consider re-gathering context if state changed significantly.")
                # Example: self.current_context = self.context_builder.gather_context(os_type=self.os_type)

            return f"Execution Status: {execution_status_msg}\nDevice Output:\n{device_output}\nFeedback: {feedback_result}"
        else:
            app_logger.info(f"[{self.device_id}] Execution skipped by user or auto_execute=False.")
            log_interaction(app_logger, self.device_id, user_query, llm_suggested_commands, "SKIPPED", "Execution skipped.", False)
            return "Execution skipped."


    def cleanup_session(self):
        """Disconnects from the device."""
        if self.connector and self.connector.client:
            app_logger.info(f"[{self.device_id}] Disconnecting from device...")
            self.connector.disconnect()
        app_logger.info(f"[{self.device_id}] Session cleaned up.")


# --- Main Application Flow ---
def setup_credentials_interactive(security_manager, device_id):
    """Interactively prompts user to set up credentials for a device."""
    print(f"\n--- Credential Setup for {device_id} ---")
    username = input(f"Enter username for {device_id}: ").strip()
    from getpass import getpass
    password = getpass(f"Enter password for {device_id}: ").strip()
    if username and password:
        security_manager.set_device_credentials(device_id, username, password, save=True)
        print(f"Credentials for {device_id} stored.\n")
        return True
    else:
        print("Username or password not provided. Credentials not stored.\n")
        return False

def main_interactive_cli():
    """Main interactive CLI flow for the AI Agent."""
    app_logger.info("Starting AI Agent Application...")

    # --- Device Configuration ---
    # In a real app, this might come from a config file, a DB, or service discovery.
    # For this example, we'll define one device or ask the user.

    print("Welcome to the AI Network Agent CLI!")

    # Initialize SecurityManager early for credential setup
    # Uses key from env or generates one if AI_AGENT_ENCRYPTION_KEY is not set
    # If generated, it's ephemeral for this run unless user stores it.
    # Best to set AI_AGENT_ENCRYPTION_KEY in your environment.
    global_security_manager = SecurityManager(
        credential_store_path=CREDENTIAL_STORE_FILE,
        encryption_key=AI_AGENT_ENCRYPTION_KEY
    )
    if not AI_AGENT_ENCRYPTION_KEY and not os.path.exists(CREDENTIAL_STORE_FILE):
         app_logger.warning(f"AI_AGENT_ENCRYPTION_KEY not set and no existing credential store. A new key was generated: {global_security_manager.key.decode()}. Store this key to reuse encrypted credentials.")


    # Device selection/setup
    # For simplicity, let's pre-define or ask for one device's details
    device_ip = input("Enter device IP address: ").strip()
    device_os_type = input("Enter device OS type (linux, cisco_ios, paloalto_panos): ").strip().lower()
    device_id = input(f"Enter a unique ID/label for this device (e.g., 'lab-router-1', defaults to IP): ").strip() or device_ip

    if not device_ip or not device_os_type:
        print("Device IP and OS type are required. Exiting.")
        return

    device_config = {
        "id": device_id,
        "ip": device_ip,
        "os_type": device_os_type
    }

    # Check for credentials, set up if missing
    if not global_security_manager.get_device_credentials(device_id):
        print(f"Credentials for {device_id} not found in store ({CREDENTIAL_STORE_FILE}).")
        if input("Do you want to set them up now? (yes/no) [yes]: ").strip().lower() in ['yes', 'y', '']:
            if not setup_credentials_interactive(global_security_manager, device_id):
                print(f"Cannot proceed without credentials for {device_id}. Exiting.")
                return
        else:
            print(f"Cannot proceed without credentials for {device_id}. Exiting.")
            return

    # --- Initialize Agent for the chosen device ---
    agent = AIAgent(device_config, OPENAI_API_KEY,
                    agent_encryption_key=global_security_manager.key, # Pass the key being used
                    cred_store_path=CREDENTIAL_STORE_FILE)

    if not agent.initialize_agent_session():
        app_logger.error(f"Failed to initialize agent session for {agent.device_id}. Check connection or context gathering errors.")
        print(f"Could not initialize session with {agent.device_id}. Please check logs and device status.")
        return

    print(f"\nSuccessfully connected to {agent.device_id}. Current context summary:")
    print(json.dumps(agent.current_context, indent=2, sort_keys=True))
    print("\nReady for your requests!")
    print("Type 'exit', 'quit' or 'bye' to end the session.")
    print("Type 'context' to view current device context.")
    print("Type 'reconnect' to re-establish connection and refresh context.")


    # --- Main Interaction Loop ---
    while True:
        try:
            user_input = input(f"\n[{agent.device_id}] Your request: ").strip()
        except EOFError: # Handle Ctrl+D or piped input ending
            print("\nEOF received, exiting.")
            break
        except KeyboardInterrupt: # Handle Ctrl+C
            print("\nInterrupt received, exiting.")
            break


        if not user_input:
            continue
        if user_input.lower() in ["exit", "quit", "bye"]:
            print("Exiting AI Agent CLI...")
            break
        if user_input.lower() == "context":
            print("\nCurrent Device Context:")
            print(json.dumps(agent.current_context, indent=2, sort_keys=True))
            continue
        if user_input.lower() == "reconnect":
            print("Re-initializing session...")
            agent.cleanup_session() # Disconnect first
            if not agent.initialize_agent_session():
                 print(f"Failed to re-initialize session with {agent.device_id}. Check logs.")
            else:
                print("Session re-initialized. Context refreshed.")
                print(json.dumps(agent.current_context, indent=2, sort_keys=True))
            continue


        # Process the natural language request
        # Set auto_execute to False for interactive CLI, True for fully automated scenarios
        result_message = agent.process_user_request(user_input, auto_execute=False)
        print(f"\n--- Agent Response ---")
        print(result_message)
        print("----------------------")

    agent.cleanup_session()
    app_logger.info("AI Agent Application finished.")


if __name__ == "__main__":
    # Ensure OPENAI_API_KEY is set
    if not OPENAI_API_KEY:
        print("CRITICAL: OPENAI_API_KEY environment variable is not set.")
        print("The LLM Query Engine will not function.")
        if input("Continue without LLM capabilities (not recommended)? (yes/no) [no]:").strip().lower() != "yes":
            exit(1)

    main_interactive_cli()
